package com.p2m.core.module

import android.content.Context
import com.p2m.core.internal.channel.ChannelInterceptorContainer
import com.p2m.core.internal.moduleName
import com.p2m.core.internal.module.ModuleUnitImpl
import com.p2m.core.internal.module.ModuleVisitor
import com.p2m.core.launcher.ILaunchActivityInterceptor
import com.p2m.core.module.task.TaskOutputProvider
import com.p2m.core.module.task.TaskRegister
import kotlin.reflect.KClass

/**
 * Public sub class of module is auto generated by `APT`, it's class name
 * is defined module name in `settings.gradle`.
 *
 * Each module has a `api` is exposed for external module after the module
 * is initialized internally, please see [ModuleInit] for initialization.
 *
 * Call `P2M.apiOf(module name)` to get [api]. For example, `Main` module use
 * `Account` module, so `Main` depends on `Account`, in `settings.gradle`:
 * ```
 * apply plugin: "p2m-android"
 * p2m {
 *      module("Account") {
 *          // some configuration
 *      }
 *
 *      module("Main") {
 *          dependencies {
 *              module("Account")
 *          }
 *      }
 * }
 * ```
 * Get [api] of `Account` after compilation`:
 * ```
 * val accountApi = P2M.apiOf(Account)
 * val accountLauncher = accountApi.launcher
 * val accountService = accountApi.service
 * val accountEvent = accountApi.event
 * ```
 *
 * see more at [doc](https://github.com/wangdaqi77/P2M)
 *
 * @see ModuleApi  - api class of a module.
 * @see ModuleInit - initialization class of a module.
 */
abstract class Module<MODULE_API : ModuleApi<*, *, *>> {
    abstract val api: MODULE_API
    protected abstract val init: ModuleInit
    @Suppress("UNCHECKED_CAST")
    protected open val publicClass: Class<out Module<*>> = this.javaClass.superclass as Class<out Module<*>>
    internal lateinit var interceptorContainer: ChannelInterceptorContainer
    internal val dependencies = hashSetOf<String>()
    private var launchActivityInterceptors : MutableMap<KClass<out ILaunchActivityInterceptor>, ILaunchActivityInterceptor>? = null
    internal val internalInit: Init = object : Init() {
        override fun onEvaluate(context: Context, taskRegister: TaskRegister) {
            init.onEvaluate(context, taskRegister)
        }

        override fun onExecute(context: Context) {
            interceptorContainer.getInterceptors(this@Module)
                ?.forEach { it.init(context) }
            launchActivityInterceptors = null
        }

        override fun onCompleted(context: Context, taskOutputProvider: TaskOutputProvider) {
            init.onCompleted(context, taskOutputProvider)
        }
    }

    internal val internalModuleUnit by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {
        ModuleUnitImpl(this, this.javaClass, publicClass)
    }

    internal fun initLazy(interceptorContainer: ChannelInterceptorContainer) {
        this.interceptorContainer = interceptorContainer
        this.launchActivityInterceptors?.forEach { entry ->
            this.interceptorContainer.registerFromModule(this, entry.key, entry.value)
        }
    }

    internal fun accept(visitor: ModuleVisitor){
        visitor.visit(this)
    }

    protected fun dependOn(moduleName: String) {
        dependencies.add(moduleName)
    }

    protected fun collectInterceptorForLaunchActivity(interceptorClass: KClass<out ILaunchActivityInterceptor>, interceptor: ILaunchActivityInterceptor) {
        val map = launchActivityInterceptors ?: mutableMapOf<KClass<out ILaunchActivityInterceptor>, ILaunchActivityInterceptor>().also {
            launchActivityInterceptors = it
        }
        map[interceptorClass] = interceptor
    }

    override fun hashCode(): Int {
        return publicClass.moduleName.hashCode()
    }

    override fun equals(other: Any?): Boolean {
        if (other == null) return false
        if (other !is Module<*>) return false
        return publicClass.moduleName == other.publicClass.moduleName
    }

    override fun toString(): String {
        return publicClass.moduleName
    }

    internal abstract class Init : ModuleInit {
        abstract fun onExecute(context: Context)
    }
}