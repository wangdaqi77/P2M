package com.p2m.core.module

import android.content.Context
import com.p2m.core.internal.channel.ChannelInterceptorContainer
import com.p2m.core.internal.moduleName
import com.p2m.core.internal.module.ModuleUnitImpl
import com.p2m.core.internal.module.ModuleVisitor
import com.p2m.core.launcher.ILaunchActivityInterceptor
import com.p2m.core.module.task.TaskOutputProvider
import com.p2m.core.module.task.TaskRegister
import kotlin.reflect.KClass

/**
 * Each module has one and only one [Module] on runtime, it has a `init` for
 * its own initialization, and has a `api` is exposed for its own and external module.
 *
 * Public sub class of each module is auto generated by P2M-APT,  it's class name
 * is defined module name in `settings.gradle`.
 *
 * External module can access `api` when its own `init` initialization be completed,
 *
 * Call `P2M.apiOf(public module class of dependency)` to get instance of `api`.
 *
 * For example, `Main` module use `Account` module, so `Main` depends on `Account`,
 * in `settings.gradle`:
 * ```
 * apply plugin: "p2m-android"
 * p2m {
 *      module("Account") {
 *          // some configuration
 *      }
 *
 *      module("Main") {
 *          dependencies {
 *              module("Account")
 *          }
 *      }
 * }
 * ```
 * Get instance of `api` of `Account` in `Main`:
 * ```
 * val accountApi = P2M.apiOf(Account)
 * val accountLauncher = accountApi.launcher
 * val accountService = accountApi.service
 * val accountEvent = accountApi.event
 * ```
 *
 * see more at [doc](https://github.com/wangdaqi77/P2M)
 *
 * @see ModuleApi  - a module api.
 * @see ModuleInit - a module initialization.
 */
abstract class Module<MODULE_API : ModuleApi<*, *, *>> {
    abstract val api: MODULE_API
    protected abstract val init: ModuleInit
    @Suppress("UNCHECKED_CAST")
    protected open val publicClass: Class<out Module<*>> = this.javaClass.superclass as Class<out Module<*>>
    internal lateinit var interceptorContainer: ChannelInterceptorContainer
    internal val dependencies = hashSetOf<String>()
    private var launchActivityInterceptors : MutableMap<KClass<out ILaunchActivityInterceptor>, ILaunchActivityInterceptor>? = null
    internal val internalInit: Init = object : Init() {
        override fun onEvaluate(context: Context, taskRegister: TaskRegister) {
            init.onEvaluate(context, taskRegister)
        }

        override fun onExecute(context: Context) {
            interceptorContainer.getInterceptors(this@Module)
                ?.forEach { it.init(context) }
            launchActivityInterceptors = null
        }

        override fun onExecuted(context: Context, taskOutputProvider: TaskOutputProvider) {
            init.onExecuted(context, taskOutputProvider)
        }
    }

    internal val internalModuleUnit by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {
        ModuleUnitImpl(this, this.javaClass, publicClass)
    }

    internal fun initLazy() {
        launchActivityInterceptors?.forEach { entry ->
            interceptorContainer.register(this, entry.key, entry.value)
        }
    }

    internal fun accept(visitor: ModuleVisitor){
        visitor.visit(this)
    }

    protected fun dependOn(moduleName: String) {
        dependencies.add(moduleName)
    }

    protected fun collectInterceptorForLaunchActivity(interceptorClass: KClass<out ILaunchActivityInterceptor>, interceptor: ILaunchActivityInterceptor) {
        val map = launchActivityInterceptors ?: mutableMapOf<KClass<out ILaunchActivityInterceptor>, ILaunchActivityInterceptor>().also {
            launchActivityInterceptors = it
        }
        map[interceptorClass] = interceptor
    }

    override fun hashCode(): Int {
        return publicClass.moduleName.hashCode()
    }

    override fun equals(other: Any?): Boolean {
        if (other == null) return false
        if (other !is Module<*>) return false
        return publicClass.moduleName == other.publicClass.moduleName
    }

    override fun toString(): String {
        return publicClass.moduleName
    }

    internal abstract class Init : ModuleInit {
        abstract fun onExecute(context: Context)
    }
}